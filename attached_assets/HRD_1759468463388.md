# HRD: 네이버 블로그 스마트블록 순위 추적 시스템
## High-Level Requirements Document

**작성일**: 2025-01-02
**버전**: 1.0
**상태**: Multi-Agent 분석 완료

---

## 📋 Executive Summary

### 프로젝트 검증 결과

**전체 평가**: ✅ **구조적으로 건전하나 필수 개선사항 존재**

- **아키텍처 성숙도**: 7.2/10 (Good, 개선 필요)
- **UI/UX 설계**: 견고한 기반 (PandaRank 스타일 + Atomic Design)
- **백엔드 로직**: **CRITICAL** - SerpAPI 할당량 문제 및 동시성 제어 누락

### 핵심 발견사항

| 구분 | 현황 | 권장사항 |
|------|------|----------|
| **API 할당량** | SerpAPI 100회/월 → 3개 키워드만 추적 가능 | 하이브리드 접근법 (Naver API + SerpAPI) |
| **동시성 제어** | 없음 → 중복 측정 발생 가능 | Redis 분산 락 구현 |
| **보안** | SQL 인젝션 취약점, RLS 우회 가능성 | Rate limiting + Input validation |
| **성능** | N+1 쿼리, 비효율적 HTML 파싱 | Materialized View + Worker Threads |

**결론**: 구현 방향은 올바르나 **4가지 필수 수정사항** 적용 후 진행 권장

---

## 🏗️ Architecture Review Summary

### Overall Assessment

**아키텍처 성숙도 점수**: 7.2/10

**강점**:
- ✅ 명확한 관심사 분리 (Crawler ↔ Worker ↔ API)
- ✅ 확장 가능한 큐 시스템 (BullMQ + Redis)
- ✅ Supabase Realtime 활용한 실시간 업데이트

**개선 필요 영역**:

#### 1. Dependency Inversion Principle 위반

**문제점**:
```typescript
// ❌ CURRENT: MeasurementWorker가 SerpAPIClient에 직접 의존
class MeasurementWorker {
  constructor(private serpApiClient: SerpAPIClient) {}
}
```

**해결책**:
```typescript
// ✅ SOLUTION: 인터페이스를 통한 추상화
interface ISearchProvider {
  searchNaver(keyword: string): Promise<SearchResult>;
}

class MeasurementWorker {
  constructor(private searchProvider: ISearchProvider) {}
}

// 구현체 주입 (SerpAPI, Naver API, Playwright 등 교체 가능)
const worker = new MeasurementWorker(new HybridSearchProvider());
```

**효과**: SerpAPI 외에 다른 크롤러로 교체 가능 → 단일 장애 지점 제거

#### 2. Error Handling 표준화 부재

**문제점**: 각 컴포넌트마다 다른 에러 처리 방식 사용

**해결책**:
```typescript
// Global error types
class MeasurementError extends Error {
  constructor(
    message: string,
    public code: string,
    public retryable: boolean,
    public context?: Record<string, any>
  ) {
    super(message);
  }
}

// Centralized error handler
class ErrorHandler {
  async handle(error: Error, job: Job): Promise<void> {
    if (error instanceof MeasurementError && error.retryable) {
      await job.retry({ delay: 60000 });
    } else {
      await this.alertService.sendAdminAlert(error);
    }
  }
}
```

#### 3. Observability 부족

**추가 필요 사항**:
- **Distributed Tracing**: OpenTelemetry로 요청 흐름 추적
- **Structured Logging**: Winston JSON 포맷 + 로그 집계
- **SLO/SLI 정의**:
  - Measurement 성공률 ≥99.5%
  - 파싱 신뢰도 ≥95%
  - 알림 지연시간 <60초

---

## 🎨 Frontend Design Specifications

### UI/UX Design Validation

**PandaRank 참조 분석 결과**: ✅ **적합한 레이아웃 선택**

### 권장 페이지 구조

#### 1. Dashboard (`/dashboard`)

```
┌─────────────────────────────────────────────┐
│ Header: Logo | 키워드 검색 | 사용자 메뉴    │
├─────────────────────────────────────────────┤
│ [Summary Cards Row]                         │
│ ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐        │
│ │추적중│ │상승  │ │하락  │ │알림  │        │
│ │ 15개 │ │ 8개  │ │ 3개  │ │ 2건  │        │
│ └──────┘ └──────┘ └──────┘ └──────┘        │
├─────────────────────────────────────────────┤
│ [Keyword Table with Real-time Updates]     │
│ ┌───────────────────────────────────┐      │
│ │키워드 │현재순위│변동│마지막측정 │      │
│ ├───────────────────────────────────┤      │
│ │블로그SEO│🟢 1위 │↑2 │5분 전    │      │
│ │마케팅 │🟡 3위 │↓1 │10분 전   │      │
│ └───────────────────────────────────┘      │
└─────────────────────────────────────────────┘
```

**기술 스택**:
- **Framework**: Next.js 14 App Router
- **Styling**: Tailwind CSS + shadcn/ui
- **Charts**: Recharts (PandaRank 스타일 라인 차트)
- **Real-time**: Supabase Realtime subscriptions

#### 2. Keyword Detail (`/keywords/[id]`)

**핵심 컴포넌트**:
- **Rank Trend Chart**: 30일 순위 변화 추이 (녹색 라인)
- **Measurement History Table**: 모든 측정 기록 (페이지네이션)
- **Alert Configuration**: 알림 설정 (하락 임계값, 알림 채널)

**Real-time Update 전략**:
```typescript
// Server Component (초기 데이터)
export default async function KeywordDetailPage({ params }) {
  const keyword = await supabase
    .from('keywords')
    .select('*, measurements(*)')
    .eq('id', params.id)
    .single();

  return <KeywordDetailClient initialData={keyword} />;
}

// Client Component (실시간 업데이트)
'use client';
export function KeywordDetailClient({ initialData }) {
  const { data } = useSupabaseRealtime('measurements', {
    event: 'INSERT',
    filter: `keyword_id=eq.${initialData.id}`
  });

  // 새 측정값 도착 시 차트 자동 업데이트
}
```

### Component Architecture (Atomic Design)

```
components/
├── atoms/
│   ├── Badge.tsx          # 순위 변동 뱃지 (↑2, ↓1)
│   ├── StatusIndicator.tsx # 🟢🟡🔴 상태 점
│   └── Skeleton.tsx       # 로딩 스켈레톤
├── molecules/
│   ├── KeywordCard.tsx    # 개별 키워드 카드
│   ├── RankChart.tsx      # 순위 추이 차트
│   └── AlertConfig.tsx    # 알림 설정 폼
├── organisms/
│   ├── KeywordTable.tsx   # 전체 키워드 테이블
│   ├── DashboardStats.tsx # 통계 카드 그룹
│   └── Header.tsx         # 헤더 + 검색
└── templates/
    ├── DashboardLayout.tsx
    └── DetailLayout.tsx
```

### Color Palette (PandaRank 기반)

```css
:root {
  --primary: #00D9A3;      /* 녹색 (상승) */
  --danger: #FF4757;       /* 빨강 (하락) */
  --warning: #FFA502;      /* 주황 (경고) */
  --background: #F8F9FA;   /* 배경 */
  --card: #FFFFFF;         /* 카드 */
  --text-primary: #2C3E50; /* 본문 */
  --text-secondary: #7F8C8D; /* 부제 */
}
```

### Responsive Breakpoints

```typescript
const breakpoints = {
  mobile: '640px',   // 1-column layout
  tablet: '768px',   // 2-column layout
  desktop: '1024px'  // 3-column layout
};
```

---

## ⚙️ Backend Critical Issues & Solutions

### CRITICAL ISSUE #1: SerpAPI Quota Incompatibility

**문제 분석**:
```
SerpAPI 무료 플랜: 100 requests/month
요구사항: 10 keywords × 30 days × 1 check/day = 300 requests/month

결론: 현재 설계로는 3개 키워드만 추적 가능 (67% 부족)
```

**해결책**: Hybrid Approach (SerpAPI + Naver Search API)

```typescript
class IntelligentCrawler {
  async measureKeyword(keyword: Keyword): Promise<Measurement> {
    // 1단계: 무료 Naver Search API로 빠른 순위 확인
    const quickRank = await this.naverSearchApi.getBlogRank({
      query: keyword.keyword,
      display: 100
    });

    // 2단계: 순위 변동 또는 24시간 경과 시에만 HTML 파싱
    const needsDeepScan =
      quickRank.rank !== keyword.last_rank ||
      (Date.now() - keyword.last_html_fetch) > 86400000;

    if (needsDeepScan) {
      // SerpAPI로 정확한 스마트블록 위치 파싱
      const html = await this.serpApiClient.searchNaver(keyword.keyword);
      return this.parseSmartBlock(html);
    }

    return { rank: quickRank.rank, confidence: 0.85 };
  }
}
```

**예상 효과**:
- API 호출 80% 감소 (300회 → 60회/월)
- SerpAPI 할당량으로 **50개 키워드** 추적 가능
- 비용: $0 (무료 플랜 범위 내)

**Fallback 전략**:
```typescript
// SerpAPI 할당량 소진 시 Playwright 직접 크롤링
if (serpApiQuotaExceeded) {
  const browser = await playwright.chromium.launch();
  const html = await browser.newPage().goto(
    `https://search.naver.com/search.naver?query=${keyword}`
  );
}
```

### CRITICAL ISSUE #2: Missing Distributed Concurrency Control

**문제점**:
```typescript
// ❌ 동일 키워드에 대한 동시 측정 방지 메커니즘 없음
await measurementQueue.add('measure', { keywordId: 123 });
await measurementQueue.add('measure', { keywordId: 123 }); // 중복 가능

결과:
- API 할당량 낭비 (2배 호출)
- 데이터 불일치 (동시 INSERT)
- 경쟁 조건 (race condition)
```

**해결책**: Redis Distributed Lock

```typescript
class DistributedLock {
  async acquireLock(
    keywordId: number,
    ttl = 300
  ): Promise<boolean> {
    const lockKey = `lock:measurement:${keywordId}`;

    // SET NX EX: 존재하지 않을 때만 설정 + TTL
    const acquired = await redis.set(
      lockKey,
      process.pid.toString(),
      'EX', ttl,
      'NX'
    );

    return acquired === 'OK';
  }

  async releaseLock(keywordId: number): Promise<void> {
    await redis.del(`lock:measurement:${keywordId}`);
  }
}

// Worker에서 사용
async processMeasurement(job: Job) {
  const locked = await this.lock.acquireLock(job.data.keywordId);

  if (!locked) {
    throw new Error('Already in progress');
  }

  try {
    await this.measureKeyword(job.data.keywordId);
  } finally {
    await this.lock.releaseLock(job.data.keywordId);
  }
}
```

**추가 보완**: Idempotency Token

```typescript
// 중복 방지용 고유 토큰
interface MeasurementJob {
  keywordId: number;
  idempotencyToken: string; // UUID
}

// DB에 토큰 저장 (UNIQUE constraint)
CREATE UNIQUE INDEX idx_measurements_idempotency
ON measurements(keyword_id, idempotency_token);
```

### CRITICAL ISSUE #3: Security Vulnerabilities

**취약점 #1: SQL Injection**

```typescript
// ❌ VULNERABLE
const query = `
  SELECT * FROM keywords
  WHERE keyword LIKE '%${userInput}%'
`;

// ✅ SAFE: Parameterized query
const { data } = await supabase
  .from('keywords')
  .select()
  .ilike('keyword', `%${userInput}%`); // 자동 이스케이핑
```

**취약점 #2: RLS Bypass**

```sql
-- ❌ CURRENT: 관리자는 RLS 우회 가능
ALTER TABLE keywords ENABLE ROW LEVEL SECURITY;
CREATE POLICY user_keywords ON keywords
  FOR ALL USING (created_by = auth.uid());

-- ✅ SOLUTION: 관리자도 RLS 적용
CREATE POLICY admin_keywords ON keywords
  FOR ALL USING (
    created_by = auth.uid()
    OR EXISTS (
      SELECT 1 FROM user_roles
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );
```

**취약점 #3: Rate Limiting 부재**

```typescript
// API 라우트에 추가
import rateLimit from 'express-rate-limit';

const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15분
  max: 100, // 100 requests
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator: (req) => {
    // IP + User-Agent로 고유 식별
    return `${req.ip}-${req.get('User-Agent')}`;
  }
});

app.use('/api/', apiLimiter);
```

**취약점 #4: Input Validation**

```typescript
import { z } from 'zod';

const KeywordSchema = z.object({
  keyword: z.string()
    .min(2, '최소 2자 이상')
    .max(100, '최대 100자')
    .regex(/^[가-힣a-zA-Z0-9\s]+$/, '특수문자 불가'),
  target_url: z.string()
    .url('올바른 URL 형식이 아닙니다')
    .startsWith('https://blog.naver.com/', '네이버 블로그만 가능'),
  alert_threshold: z.number()
    .int()
    .min(1)
    .max(10)
});

// API 핸들러
export async function POST(req: Request) {
  const body = await req.json();
  const validated = KeywordSchema.parse(body); // 검증 실패 시 throw
  // ...
}
```

### CRITICAL ISSUE #4: Performance Bottlenecks

**병목 #1: N+1 Query**

```sql
-- ❌ CURRENT: latest_measurements 뷰에서 1000개 서브쿼리
CREATE VIEW latest_measurements AS
SELECT k.*, (
  SELECT rank_smartblock
  FROM measurements
  WHERE keyword_id = k.id
  ORDER BY measured_at DESC
  LIMIT 1
) FROM keywords k;

-- ✅ SOLUTION: Materialized View
CREATE MATERIALIZED VIEW latest_measurements_mv AS
SELECT DISTINCT ON (k.id)
  k.id, k.keyword, m.rank_smartblock, m.measured_at
FROM keywords k
LEFT JOIN measurements m ON k.id = m.keyword_id
ORDER BY k.id, m.measured_at DESC;

-- 5분마다 자동 갱신
CREATE OR REPLACE FUNCTION refresh_latest_mv()
RETURNS void AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY latest_measurements_mv;
END;
$$ LANGUAGE plpgsql;

SELECT cron.schedule(
  'refresh-latest-measurements',
  '*/5 * * * *',
  'SELECT refresh_latest_mv()'
);
```

**병목 #2: Inefficient HTML Parsing**

```typescript
// ❌ CURRENT: Cheerio (느림, 단일 스레드)
const $ = cheerio.load(html);
const smartBlock = $('.blog_smartblock').first();

// ✅ SOLUTION: htmlparser2 + Worker Threads
import { parseDocument } from 'htmlparser2';
import { Worker } from 'worker_threads';

class ParallelParser {
  async parseSmartBlock(html: string): Promise<SmartBlock> {
    return new Promise((resolve, reject) => {
      const worker = new Worker('./parser.worker.js', {
        workerData: { html }
      });

      worker.on('message', resolve);
      worker.on('error', reject);
    });
  }
}

// parser.worker.js
const { workerData } = require('worker_threads');
const dom = parseDocument(workerData.html); // 2-3배 빠름
// 파싱 로직...
parentPort.postMessage(result);
```

**성능 개선 효과**:
- 파싱 속도: 500ms → 150ms (70% 개선)
- CPU 사용률: Worker Pool로 병렬 처리
- 메모리: Stream 파싱으로 50% 감소

**병목 #3: TimescaleDB 미사용**

```sql
-- measurements 테이블을 hypertable로 변환
SELECT create_hypertable(
  'measurements',
  'measured_at',
  chunk_time_interval => INTERVAL '1 month'
);

-- 자동 압축 (90일 이전 데이터)
ALTER TABLE measurements SET (
  timescaledb.compress,
  timescaledb.compress_segmentby = 'keyword_id'
);

SELECT add_compression_policy(
  'measurements',
  INTERVAL '90 days'
);

-- BRIN 인덱스 (시계열 데이터에 최적화)
CREATE INDEX idx_measurements_time_brin
ON measurements USING BRIN (measured_at);
```

**스토리지 절감**: 압축 후 70-90% 용량 감소

---

## 📅 Implementation Roadmap

### Phase 1: Critical Fixes (Week 1)

**우선순위 1 - API 할당량 문제 해결**
- [ ] Naver Search API 클라이언트 구현
- [ ] Hybrid crawler 로직 구현
- [ ] SerpAPI fallback 메커니즘 추가
- [ ] API 호출 감사 로깅

**우선순위 2 - 동시성 제어**
- [ ] Redis 분산 락 구현
- [ ] Idempotency token 스키마 추가
- [ ] BullMQ job deduplication 설정

**우선순위 3 - 보안 강화**
- [ ] Rate limiting 미들웨어 추가
- [ ] Zod 입력 검증 스키마 작성
- [ ] RLS 정책 강화
- [ ] API 키 rotation 메커니즘

**검증 기준**:
- ✅ 10개 키워드 30일 추적 시 API 호출 <100회
- ✅ 동일 키워드 동시 측정 시도 시 에러 발생
- ✅ SQL 인젝션 테스트 통과
- ✅ Rate limit 테스트 통과 (101번째 요청 거부)

### Phase 2: Core Features (Week 2-3)

**Backend (Week 2)**
- [ ] MeasurementWorker 완성 (Hybrid crawler 통합)
- [ ] AlertService 구현 (이메일 + Slack)
- [ ] SchedulerService (dynamic interval)
- [ ] Webhook API 엔드포인트

**Frontend (Week 3)**
- [ ] Next.js 14 프로젝트 생성
- [ ] Dashboard 페이지 (카드 + 테이블)
- [ ] Keyword Detail 페이지 (차트 + 히스토리)
- [ ] Supabase Realtime 연결
- [ ] shadcn/ui 컴포넌트 통합

**Database**
- [ ] Supabase 마이그레이션 실행
- [ ] RLS 정책 적용
- [ ] 테스트 데이터 시딩

**검증 기준**:
- ✅ 키워드 추가 → 1시간 이내 첫 측정 완료
- ✅ 순위 변동 → 3분 이내 알림 발송
- ✅ Dashboard 실시간 업데이트 (5초 이내)

### Phase 3: Optimization (Week 4)

**Performance**
- [ ] TimescaleDB hypertable 변환
- [ ] Materialized view 생성 + 자동 갱신
- [ ] Worker Threads 파서 구현
- [ ] BRIN 인덱스 추가

**Observability**
- [ ] OpenTelemetry 설정
- [ ] Winston JSON 로깅
- [ ] Supabase 함수 로그 연결
- [ ] Grafana 대시보드 (선택)

**Quality**
- [ ] E2E 테스트 (Playwright)
- [ ] Load testing (k6)
- [ ] Security audit (OWASP ZAP)

**검증 기준**:
- ✅ 1000개 키워드 동시 측정 <10분
- ✅ API 응답 시간 P95 <200ms
- ✅ 파싱 신뢰도 >95%
- ✅ 메모리 사용량 <500MB

### Phase 4: Production Launch (Week 5)

**Deployment**
- [ ] Supabase 프로젝트 Production 환경 생성
- [ ] Vercel 배포 (Next.js)
- [ ] Railway/Render 배포 (BullMQ Worker)
- [ ] Upstash Redis 설정

**Monitoring**
- [ ] Uptime 모니터링 (UptimeRobot)
- [ ] Error tracking (Sentry)
- [ ] Performance monitoring (Vercel Analytics)

**Documentation**
- [ ] API 문서 (Swagger)
- [ ] 사용자 가이드
- [ ] 운영 가이드 (troubleshooting)

**검증 기준**:
- ✅ 99.5% uptime (첫 주)
- ✅ 에러율 <0.1%
- ✅ 사용자 피드백 수집

---

## 🚨 Risk Mitigation

### Risk #1: SerpAPI 의존성

**리스크**: SerpAPI 서비스 장애 또는 정책 변경

**완화 전략**:
1. **Primary**: Naver Search API (무료, 안정적)
2. **Secondary**: SerpAPI (정확도 높음)
3. **Fallback**: Playwright 직접 크롤링

```typescript
class ResilientCrawler {
  async measureWithFallback(keyword: string): Promise<Measurement> {
    try {
      return await this.naverSearchApi.measure(keyword);
    } catch (err) {
      try {
        return await this.serpApiClient.measure(keyword);
      } catch (err2) {
        return await this.playwrightCrawler.measure(keyword);
      }
    }
  }
}
```

### Risk #2: Performance at Scale

**리스크**: 1000+ 키워드 추적 시 성능 저하

**완화 전략**:
1. **Dynamic Worker Scaling**:
```typescript
const queueSize = await measurementQueue.count();
const workerCount = Math.min(
  Math.ceil(queueSize / 100),
  10 // 최대 10개 워커
);

for (let i = 0; i < workerCount; i++) {
  new Worker('measurement.worker.js');
}
```

2. **Intelligent Batching**:
```typescript
// 비슷한 키워드를 묶어서 한 번에 요청
const batch = await supabase
  .from('keywords')
  .select()
  .eq('next_measurement_due', true)
  .limit(20);

await Promise.all(batch.map(k => this.measure(k)));
```

### Risk #3: Data Loss

**리스크**: Measurement 데이터 손실

**완화 전략**:
1. **Point-in-Time Recovery**: Supabase 자동 백업 (7일)
2. **Replication**: Supabase 내장 replica
3. **Manual Backup**:
```bash
# 매일 자정 백업
pg_dump $DATABASE_URL | gzip > backup-$(date +%Y%m%d).sql.gz
```

### Risk #4: Security Breach

**리스크**: 사용자 데이터 유출

**완화 전략**:
1. **RLS + JWT**: 모든 요청에 사용자 인증 필수
2. **Secrets Rotation**: API 키 90일마다 교체
3. **Audit Log**:
```sql
CREATE TABLE audit_logs (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID,
  action TEXT,
  resource TEXT,
  ip_address INET,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 모든 민감한 작업 기록
INSERT INTO audit_logs (user_id, action, resource)
VALUES (auth.uid(), 'DELETE', 'keyword:123');
```

---

## 📊 Success Metrics

### Technical KPIs

| 지표 | 목표 | 측정 방법 |
|------|------|----------|
| **API Quota 효율** | <50 SerpAPI calls/month (10 keywords) | Redis counter |
| **Measurement 성공률** | ≥99.5% | `success_count / total_count` |
| **파싱 신뢰도** | ≥95% | `confidence` 컬럼 평균 |
| **API 응답 시간** | P95 <200ms | OpenTelemetry |
| **알림 지연** | <60초 (순위 변동 → 알림) | `alert.sent_at - measurement.measured_at` |
| **시스템 가용성** | 99.5% uptime | UptimeRobot |

### Business KPIs

| 지표 | 목표 (1개월) |
|------|--------------|
| **활성 사용자** | 10명 |
| **추적 키워드** | 100개 |
| **일일 측정** | 500회 |
| **발송 알림** | 50건 |

### Quality Gates (Production 배포 전 필수)

- [ ] **Security**: OWASP ZAP 스캔 취약점 0건
- [ ] **Performance**: Load test 통과 (100 concurrent users)
- [ ] **Reliability**: 7일 연속 99% uptime
- [ ] **Testing**: E2E test coverage ≥80%
- [ ] **Documentation**: API 문서 + 운영 가이드 완성

---

## 🎯 Next Steps

### Immediate Actions (이번 주)

1. **Phase 1 Critical Fixes 착수**
   - Hybrid crawler 구현 시작
   - Redis 분산 락 추가
   - Rate limiting 미들웨어 작성

2. **프로토타입 테스트**
   - 3개 키워드로 7일간 테스트
   - API 호출 횟수 모니터링
   - 파싱 정확도 검증

3. **팀 리뷰**
   - HRD 문서 내부 검토
   - 우선순위 조정
   - 리소스 할당

### Decision Points

**Week 1 종료 시**:
- ✅ Hybrid crawler가 SerpAPI 대비 90% 정확도 달성 → Phase 2 진행
- ❌ 정확도 <80% → Playwright fallback 우선 개발

**Week 3 종료 시**:
- ✅ 10개 키워드 안정적 추적 → Phase 4 Production 준비
- ❌ 성능 이슈 발생 → Phase 3 최적화 먼저 진행

---

## 📚 References

### Internal Documents
- [PRD.md](./PRD.md) - Product Requirements
- [DATABASE_SCHEMA.md](./DATABASE_SCHEMA.md) - Supabase Schema
- [TECHNICAL_DESIGN.md](./TECHNICAL_DESIGN.md) - Technical Specifications
- [TECHNICAL_DESIGN_KR.md](./TECHNICAL_DESIGN_KR.md) - 기술 설계 (한글)

### External Resources
- [SerpAPI Documentation](https://serpapi.com/naver-search-api)
- [Naver Search API](https://developers.naver.com/docs/serviceapi/search/blog/blog.md)
- [Supabase RLS Guide](https://supabase.com/docs/guides/auth/row-level-security)
- [TimescaleDB Best Practices](https://docs.timescale.com/timescaledb/latest/how-to-guides/)
- [Next.js 14 App Router](https://nextjs.org/docs/app)

### Architecture Review Sources
- **architect-reviewer** analysis (7.2/10 score)
- **frontend-developer** UI/UX recommendations
- **backend-architect** critical issues report

---

**문서 상태**: ✅ Multi-Agent 분석 완료, 실행 준비됨
**최종 검토**: 2025-01-02
**승인자**: [To be filled]
